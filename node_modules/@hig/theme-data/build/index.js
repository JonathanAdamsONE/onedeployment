'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var tinycolor = _interopDefault(require('tinycolor2'));

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

/**
 * extendTheme
 * @param {*} theme
 * @param {*} extension
 *
 * Add additional roles to a theme
 */
function extendTheme(theme, extension) {
  // NOTE: We do *not* use Object spread in `reduce`, because it copies the entire
  // object in every iteration and becomes a performance bottleneck. Instead, we
  // copy `theme` once at the beginning and then apply changes to that same
  // object instance `acc` using property assignment and `Object.assign`.
  return Object.keys(extension).reduce(function (acc, key) {
    if (!acc[key]) {
      acc[key] = extension[key];
    } else {
      acc[key] = Object.assign({}, acc[key], extension[key]);
    }
    return acc;
  }, _extends({}, theme));
}

function mapValues(object, iterator) {
  // NOTE: We do *not* use Object spread in `reduce`, since it copies the entire
  // object in every iteration and becomes a performance bottleneck
  return Object.keys(object).reduce(function (acc, key) {
    acc[key] = iterator(object, key);
    return acc;
  }, {});
}

var _extends$1 = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function errorMsg(msg, referencingRole) {
  if (referencingRole) {
    return "Role " + referencingRole + ": " + msg;
  }
  return msg;
}

function dereferenceValue(theme, role, referencingRole) {
  var valueData = theme[role];
  if (valueData === undefined) {
    throw new Error(errorMsg("Role \"" + role + "\" is not present in theme", referencingRole));
  }
  if (valueData.value === null) {
    throw new Error(errorMsg("You must provide a value for role \"" + role + "\"", referencingRole));
  }

  if (valueData.value && valueData.value.ref) {
    var dereferencedValue = dereferenceValue(theme, valueData.value.ref, role);

    return _extends$1({}, dereferencedValue, valueData, {
      value: dereferencedValue.value
    });
  }
  return valueData;
}

function transformAlpha(role, valueData) {
  var color = tinycolor(valueData.value);
  if (!color.isValid()) {
    throw new Error("Role " + role + ": " + valueData.value + " is not a valid color");
  }
  return color.setAlpha(valueData.transform.alpha).toRgbString();
}

function transformColorValue(theme, role) {
  var valueData = theme[role];
  var hasAlphaTransform = valueData.transform && valueData.transform.alpha !== undefined;
  if (!hasAlphaTransform) {
    return valueData;
  }
  return _extends$1({}, valueData, {
    value: transformAlpha(role, valueData)
  });
}

function destructureValue(theme, role) {
  return theme[role].value;
}

function resolveTheme(theme) {
  return [dereferenceValue, transformColorValue, destructureValue].reduce(function (acc, fn) {
    return mapValues(acc, fn);
  }, theme);
}

exports.extendTheme = extendTheme;
exports.resolveTheme = resolveTheme;
